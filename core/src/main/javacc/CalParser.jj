
options {
	STATIC = false;
	CHOICE_AMBIGUITY_CHECK = 3;
	FORCE_LA_CHECK = false;
	DEBUG_PARSER = false;
	DEBUG_TOKEN_MANAGER = false;
	UNICODE_INPUT = true;
}



PARSER_BEGIN(CalParser)
package se.lth.cs.tycho.parsing.cal;

import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;
import se.lth.cs.tycho.ir.*;
import se.lth.cs.tycho.ir.type.*;
import se.lth.cs.tycho.ir.decl.*;
import se.lth.cs.tycho.ir.expr.*;
import se.lth.cs.tycho.ir.expr.pattern.*;
import se.lth.cs.tycho.ir.stmt.*;
import se.lth.cs.tycho.ir.stmt.lvalue.*;
import se.lth.cs.tycho.ir.entity.cal.*;
import se.lth.cs.tycho.ir.entity.cal.regexp.*;
import se.lth.cs.tycho.ir.entity.nl.*;
import se.lth.cs.tycho.ir.entity.*;
import se.lth.cs.tycho.ir.ToolAttribute;
import se.lth.cs.tycho.ir.ToolValueAttribute;
import se.lth.cs.tycho.ir.ToolTypeAttribute;
import se.lth.cs.tycho.ir.util.ImmutableList;
import se.lth.cs.tycho.ir.util.ImmutableEntry;

@SuppressWarnings("unused")
public class CalParser {

	private boolean processDescription = false;
    private boolean exprIsVar;

	private static class GenericVarDecl {
	    public int fromLine, fromCol, toLine, toCol;
	    public Availability availability = null;
	    public boolean external = false;
	    public TypeExpr type = null;
	    public String name = null;
	    public boolean constant = true;
	    public Expression value = null;
	    public List<Annotation> annotations = new ArrayList<Annotation>();
    }

	public static FunctionTypeExpr lambdaToType(ExprLambda lambda) {
		ImmutableList.Builder<TypeExpr> parameterTypes = ImmutableList.builder();
		for (ParameterVarDecl parameter : lambda.getValueParameters()) {
			parameterTypes.add(parameter.getType());
		}
		return new FunctionTypeExpr(parameterTypes.build(), lambda.getReturnType());
	}

	public static ProcedureTypeExpr procToType(ExprProc proc) {
		ImmutableList.Builder<TypeExpr> parameterTypes = ImmutableList.builder();
		for (ParameterVarDecl parameter : proc.getValueParameters()) {
			parameterTypes.add(parameter.getType());
		}
		return new ProcedureTypeExpr(parameterTypes.build());
	}

	public static <T extends AbstractIRNode> T setPosition(T node, Token from, Token to) {
		node.setPosition(from.beginLine, from.beginColumn, to.endLine, to.endColumn);
		return (T) node;
	}

	public static <T extends AbstractIRNode> T setPosition(T node, IRNode from, IRNode to) {
		node.setPosition(from, to);
		return (T) node;
	}

	public static <T extends AbstractIRNode> T setPosition(T node, Token from, IRNode to) {
		node.setPosition(from.beginLine, from.beginColumn, to.getToLineNumber(), to.getToColumnNumber());
		return (T) node;
	}

	public static <T extends AbstractIRNode> T setPosition(T node, IRNode from, Token to) {
		node.setPosition(from.getFromLineNumber(), from.getFromColumnNumber(), to.endLine, to.endColumn);
		return (T) node;
	}
}
PARSER_END(CalParser)

/* Whitespace */
SKIP :
{
	" " | "\t" | "\n" | "\r" | "\f"
}


/* Comments */
MORE :
{
  < "//" (~["\n", "\r"])* >
|
  < "/" ("*")+ "*/" >
|
  < "/" "*" (<OP>)* > : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT,IN_SINGLE_LINE_COMMENT>
MORE :
{
  < ~[] >
}


/* Keywords */
TOKEN :
{
	< ACTION: "action" >
|	< ACTOR: "actor" >
|	< ALIAS: "alias" >
|	< ALL: "all" >
|	< AND: "and" >
|	< AS: "as" >
//|	< ANY: "any" >
//|	< AT: "at" >
//|	< AT_STAR: "at*" >
|	< BEGIN: "begin" >
//|	< CHOOSE: "choose" >
|	< CASE: "case" >
|	< CONST: "const" >
//|	< DELAY: "delay" >
|	< DIV: "div" >
|	< DO: "do" >
|	< DOM: "dom" >
|	< ELSE: "else" >
|	< ELSIF: "elsif" >
|	< END: "end" >
|	< ENDACTION: "endaction" >
|	< ENDACTOR: "endactor" >
|	< ENDCASE: "endcase" >
|	< ENDCHOOSE: "endchoose" >
|	< ENDFOREACH: "endforeach" >
|	< ENDFUNCTION: "endfunction" >
|	< ENDIF: "endif" >
|	< ENDINITIALIZE: "endinitialize" >
|	< ENDINVARIANT: "endinvariant" >
|	< ENDLAMBDA: "endlambda" >
|	< ENDLET: "endlet" >
|	< ENDPRIORITY: "endpriority" >
|	< ENDPROC: "endproc" >
|	< ENDPROCEDURE: "endprocedure" >
|	< ENDSCHEDULE: "endschedule" >
|	< ENDWHILE: "endwhile" >
|	< ENTITY: "entity" >
|	< FALSE: "false" >
|	< FOR: "for" >
|	< FOREACH: "foreach" >
|	< FSM: "fsm" >
|	< FUNCTION: "function" >
|	< GENERATE: "generate" >
|	< GUARD: "guard" >
|	< IF: "if" >
|	< IMPORT: "import" >
|	< IN: "in" >
|	< INITIALIZE: "initialize" >
|   < INVARIANT: "invariant" >
|	< LAMBDA: "lambda" >
|	< LET: "let" >
|	< MAP: "map" >
|	< MOD: "mod" >
|	< MULTI: "multi" >
|	< MUTABLE: "mutable" >
|	< NAMESPACE: "namespace" >
|	< NOT: "not" >
|	< NULL: "null" >
|	< OLD: "old" >
|	< OF: "of" >
|	< OR: "or" >
|	< PRIORITY: "priority" >
|	< PROC: "proc" >
|	< PROCEDURE: "procedure" >
|	< REGEXP: "regexp" >
|	< REPEAT: "repeat" >
|	< RNG: "rng" >
|	< SCHEDULE: "schedule" >
|	< THEN: "then" >
//|	< TIME: "time" >
|	< TRUE: "true" >
|	< TYPE: "type" >
|	< VAR: "var" >
|	< WHILE: "while" >

|	< PUBLIC: "public" >
|	< PRIVATE: "private" >
|	< LOCAL: "local" >

|	< NETWORK: "network" >
|	< ENTITIES: "entities" >
|	< STRUCTURE: "structure" >
|	< EXTERNAL: "external" >
}

/* Delimiters and separators */
TOKEN: {
	< COLON: ":" >
|	< DOT: "." >
|	< COMMA: "," >
|	< LONG_DOUBLE_ARROW_RITHT: "==>" >
|	< LONG_SINGLE_ARROW_RIGHT: "-->" >
|	< LONG_SINGLE_ARROW_LEFT: "<--" >
|	< LPAREN: "(" >
|	< RPAREN: ")" >
|	< LCURLY: "{" >
|	< RCURLY: "}" >
|	< LSQUARE: "[" >
|	< RSQUARE: "]" >
}

/* Operators */
TOKEN: {
	< EQ: "=" >
|	< COLON_EQ: ":=" >
|	< SINGLE_ARROW_RIGHT: "->" >
|	< VERTICAL_BAR: "|" >
|	< GREATER_THAN: ">" >
|	< SHARP: "#" >
|	< DOT_SHARP: ".#" >
|	< STAR: "*" >
|	< DOT_STAR: ".*" >
|	< CINNAMON_BUN: "@" >
|	< OP: <OP_CHAR> (<OP_CHAR> | "=")* >
|	< #OP_CHAR: ["!", "#", "$", "%", "^", "&", "*", "/",
		"+", "-", "<", ">", "?", "~", "|", "."] >
}

/* String literals */
TOKEN: {
	< CHARACTER_LITERAL:
          "'"
          (   (~["'","\\","\n","\r"])
            | ("\\"
                ( ["n","t","b","r","f","\\","'","\""]
                | ["0"-"7"] ( ["0"-"7"] )?
                | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                )
              )
          )
          "'"
      >
    |
      < STRING_LITERAL:
          "\""
          (   (~["\"","\\","\n","\r"])
            | ("\\"
                ( ["n","t","b","r","f","\\","'","\""]
                | ["0"-"7"] ( ["0"-"7"] )?
                | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                )
              )
          )*
          "\""
      >
}


/* Numeric literals */
TOKEN: {
	< INTEGER: <DECIMAL_LITERAL> | <HEXADECIMAL_LITERAL> | <OCTAL_LITERAL> | <BINARY_LITERAL> >
|
	<REAL:
			(<DECIMAL_DIGIT>)+ "." (<DECIMAL_DIGIT>)+ (<EXPONENT>)?
		|	(<DECIMAL_DIGIT>)+ "." <EXPONENT> >
|
	<COMPLEX_REAL:
	        (<REAL>) ["+", "-"] (<REAL>) ["i", "j"]
	    |   (<INTEGER>) ["+", "-"] (<REAL>) ["i", "j"]
	    |   (<REAL>) ["+", "-"] (<INTEGER>) ["i", "j"]
	    >
|
	<COMPLEX_INT:
    	        (<INTEGER>) ["+", "-"] (<INTEGER>) ["i", "j"]>
//|
//	< REAL:
//			(<DECIMAL_DIGIT>)+ "." (<DECIMAL_DIGIT>)* (<EXPONENT>)?
//		|	"." (<DECIMAL_DIGIT>)+ (<EXPONENT>)?
//		|	(<DECIMAL_DIGIT>)+ <EXPONENT> >
|
	< #DECIMAL_LITERAL: <NON_ZERO_DECIMAL_DIGIT> (<DECIMAL_DIGIT>)* >
|
	< #HEXADECIMAL_LITERAL: "0" ["x", "X"] (<HEXADECIMAL_DIGIT>)+ >
|
	< #OCTAL_LITERAL: "0" (<OCTAL_DIGIT>)* >
|
	< #BINARY_LITERAL: "0" ["b", "B"] (<BINARY_DIGIT>)+ >
|
	< #EXPONENT: ["e", "E"] (["+", "-"])? (<DECIMAL_DIGIT>)+ >
|
	< #NON_ZERO_DECIMAL_DIGIT: ["1"-"9"] >
|
	< #DECIMAL_DIGIT: ["0"-"9"] >
|
	< #OCTAL_DIGIT: ["0"-"7"] >
|
    < #BINARY_DIGIT: ["0"-"1"] >
|
	< #HEXADECIMAL_DIGIT: ["0"-"9", "a"-"f", "A"-"F"] >
}


/* Identifies */
TOKEN: {
	< ID: (["a"-"z", "A"-"Z", "_", "$", "0"-"9"])+ >
}


NamespaceDecl CompilationUnit() :
{
	NamespaceDecl ns;
}
{
	ns = NamespaceDeclContents(QID.empty())
	<EOF>
	{
		return ns;
	}
|
	ns = NamespaceDecl()
	<EOF>
	{
		return ns;
	}
}

Annotation Annotation() :
{
	Token id;
	Token par;
	ImmutableList.Builder<AnnotationParameter> parameters = ImmutableList.builder();
	AnnotationParameter parameter;
}
{
	"@" id = <ID>
	(
		LOOKAHEAD(3)
    "("
		(
			parameter = AnnotationParameter() {parameters.add(parameter);}
			("," parameter = AnnotationParameter() {parameters.add(parameter);})*
		)?
		")"
	)?
	{ return new Annotation(id.image, parameters.build()); }
}

AnnotationParameter AnnotationParameter() :
{
	Token id;
	Expression expression = null;
	AnnotationParameter parameter;
}
{
(
	LOOKAHEAD(2)
	id=<ID> "=" expression=Expression() {parameter = new AnnotationParameter(id.image, expression);}
|
	expression=Expression() {parameter = new AnnotationParameter(null, expression);}
)
	{
        return parameter;
    }
}

NamespaceDecl NamespaceDecl() :
{
	QID qid;
	NamespaceDecl ns;
	int beginLine;
	int beginColumn;
	int endLine;
	int endColumn;
}
{
	"namespace"
	{
	    beginLine = token.beginLine;
	    beginColumn = token.beginColumn;
	    endLine = token.endLine;
	    endColumn = token.endColumn;
	}
	qid = QID()
	":"
	ns = NamespaceDeclContents(qid)
	"end"
	{
        ns.setPosition(beginLine, beginColumn, endLine, endColumn);
        return ns;
    }
}

NamespaceDecl NamespaceDeclContents(QID name) :
{
	ImmutableList.Builder<Import> imports = ImmutableList.builder();
	ImmutableList.Builder<GlobalVarDecl> varDecls = ImmutableList.builder();
	ImmutableList.Builder<GlobalEntityDecl> entityDecls = ImmutableList.builder();
	ImmutableList.Builder<GlobalTypeDecl> typeDecls = ImmutableList.builder();

	Import i;
	GlobalVarDecl v;
	GlobalEntityDecl e;
	GlobalTypeDecl t;
}
{
	(
		i = Import() ";" { imports.add(i); }
    |
        LOOKAHEAD(( Annotation() )* ("external")?  "actor")
        e = ActorDecl() { entityDecls.add(e); }
	|
		LOOKAHEAD(( Annotation() )* "network")
        e = NetworkDecl() { entityDecls.add(e); }
	|
        LOOKAHEAD(2)
        v = GlobalVarDecl() { varDecls.add(v); }
    |
		t = GlobalTypeDecl() { typeDecls.add(t); }
	)*
	{
		return new NamespaceDecl(name, imports.build(), varDecls.build(), entityDecls.build(), typeDecls.build());
	}
}

QID QID() :
{
	QID qid;
	Token id;
	int beginLine;
    int beginColumn;
}
{
	id = <ID> {
                 beginLine = id.beginLine;
                 beginColumn = id.beginColumn;
                 qid = QID.of(id.image);
                }
	(
		LOOKAHEAD(2)
		"."
		id = <ID> { qid = qid.concat(QID.of(id.image)); }
	)*
	{
        qid.setPosition(beginLine, beginColumn, id.endLine, id.endColumn);
        return qid;
    }
}

/* Declarations */
Availability Availability() :
{
}
{
	"public" { return Availability.PUBLIC; }
|
	"private" { return Availability.PRIVATE; }
|
	"local" { return Availability.LOCAL; }
}

void VariableVarDecl(GenericVarDecl varDecl) :
{
    Token id;
}
{
    { varDecl.constant = false; }
    (
        LOOKAHEAD(2)
        varDecl.type = Type()
        id = <ID>
        {
            varDecl.name = id.image;
            varDecl.fromLine = varDecl.type.getFromLineNumber();
            varDecl.fromCol = varDecl.type.getFromColumnNumber();
            varDecl.toLine = id.endLine;
            varDecl.toCol = id.endColumn;

        }
    |
        id = <ID>
        {
            varDecl.name = id.image;
            varDecl.fromLine = id.beginLine;
            varDecl.fromCol = id.beginColumn;
            varDecl.toLine = id.endLine;
            varDecl.toCol = id.endColumn;

        }
    )
    (
        (
            "=" { varDecl.constant = true; }
        |
            ":=" { varDecl.constant = false; }
        )
        varDecl.value = Expression()
        {
            varDecl.toLine = varDecl.value.getToLineNumber();
            varDecl.toCol = varDecl.value.getToColumnNumber();
        }
    )?
}

void FunctionVarDecl(GenericVarDecl varDecl) :
{
    Token id;
	ImmutableList<ParameterVarDecl> valPars;
	ImmutableList<LocalVarDecl> varDecls = null;
	TypeExpr returnType = null;
	Expression body = null;
	Annotation annotation;
	int beginLine;
	int beginColumn;
}
{
    "function"
    {
        beginLine = token.beginLine;
        beginColumn = token.beginColumn;
    }
    id = <ID>
    "("
    valPars = FormalValuePars()
    ")"
    (
        "-->" returnType = Type()
    )?
    (
        (
            "var" varDecls = BlockVarDecls()
        )?
        ":" body = Expression()
    )?
    "end"
    {
        ExprLambda lambda;
		if (varDecls == null) {
		    lambda = new ExprLambda(valPars, body, returnType);
		    lambda.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
        } else {
            ExprLet let = new ExprLet(ImmutableList.empty(), varDecls, body);
            let.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
		    lambda = new ExprLambda(valPars, let, returnType);
		    lambda.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
		}
		if (body == null) {
		    varDecl.type = lambdaToType(lambda);
		    lambda = null;
        }
		varDecl.name = id.image;
		varDecl.value = lambda;
    }
}

void ProcedureVarDecl(GenericVarDecl varDecl) :
{
	Token id;
	ImmutableList<ParameterVarDecl> valPars;
	ImmutableList<LocalVarDecl> varDecls = null;
	ImmutableList<Statement> stmts = null;
	Annotation annotation;
	int beginLine;
	int beginColumn;
}
{
	"procedure"
	{
	    beginLine = token.beginLine;
        beginColumn = token.beginColumn;
	}
	id = <ID>
	"("
    valPars = FormalValuePars()
	")"
	(
        (
            "var"
            varDecls = BlockVarDecls()
        )?
		("begin" | "do")
		stmts = Statements()
	)?
	"end"
	{
		ExprProc proc;
		if (varDecls == null) {
			proc = new ExprProc(valPars, stmts);
			proc.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
		} else {
			StmtBlock block = new StmtBlock(ImmutableList.empty(), varDecls, stmts);
			proc = new ExprProc(valPars, ImmutableList.of(block));
			proc.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
		}
		if (stmts == null) {
		    varDecl.type = procToType(proc);
		    proc = null;
        }
		varDecl.name = id.image;
		varDecl.value = proc;
	}
}

ImmutableList<LocalVarDecl> BlockVarDecls() :
{
    ImmutableList.Builder<LocalVarDecl> builder = ImmutableList.builder();
    LocalVarDecl varDecl;
}
{
    (
        varDecl = BlockVarDecl() { builder.add(varDecl); }
        ( "," varDecl = BlockVarDecl() { builder.add(varDecl); })*
    )?
    { return builder.build(); }
}

LocalVarDecl BlockVarDecl() :
{
    GenericVarDecl varDecl = new GenericVarDecl();
    ImmutableList.Builder<Annotation> annotations = ImmutableList.builder();
    Annotation annotation;
}
{
    ( annotation = Annotation() {varDecl.annotations.add(annotation);} )*
    (
        LOOKAHEAD(4)
        VariableVarDecl(varDecl)
    |
        LOOKAHEAD(( Annotation() )* "function")
        FunctionVarDecl(varDecl)
    |
        LOOKAHEAD(( Annotation() )* "procedure")
        ProcedureVarDecl(varDecl)
    )
    {
        return VarDecl.local(ImmutableList.from(varDecl.annotations), varDecl.type, varDecl.name, varDecl.value, varDecl.constant);
    }
}

LocalVarDecl LocalVarDecl() :
{
    GenericVarDecl varDecl = new GenericVarDecl();
    ImmutableList.Builder<Annotation> annotations = ImmutableList.builder();
    Annotation annotation;
}
{
    ( annotation = Annotation() {varDecl.annotations.add(annotation);} )*
    ("external" { varDecl.external = true; })?
    (
        LOOKAHEAD(4)
        VariableVarDecl(varDecl) ";"
    |
        LOOKAHEAD(( Annotation() )* "function")
        FunctionVarDecl(varDecl)
    |
        LOOKAHEAD(( Annotation() )* "procedure")
        ProcedureVarDecl(varDecl)
    )
    {
        return VarDecl.local(ImmutableList.from(varDecl.annotations), varDecl.type, varDecl.name, varDecl.value, varDecl.constant).asExternal(varDecl.external);
    }
}

GlobalVarDecl GlobalVarDecl() :
{
    ImmutableList.Builder<Annotation> annotations = ImmutableList.builder();
    Annotation annotation;
    GenericVarDecl varDecl = new GenericVarDecl();
    varDecl.availability = Availability.PUBLIC;
}
{

    ( annotation = Annotation() {varDecl.annotations.add(annotation);} )*
    (varDecl.availability = Availability())?
    ("external" { varDecl.external = true; })?
    (
        LOOKAHEAD(4)
        VariableVarDecl(varDecl) ";"
    |
        LOOKAHEAD(( Annotation() )* "function")
        FunctionVarDecl(varDecl)
    |
        LOOKAHEAD(( Annotation() )* "procedure")
        ProcedureVarDecl(varDecl)
    )
    {
		GlobalVarDecl globalVarDecl = VarDecl.global(ImmutableList.from(varDecl.annotations), varDecl.availability, varDecl.type, varDecl.name, varDecl.value).asExternal(varDecl.external);
		globalVarDecl.setPosition(varDecl.fromLine, varDecl.fromCol, varDecl.toLine, varDecl.toCol);
		return globalVarDecl;
    }
}

Import Import() :
{
	Import imp;
}
{
	"import"
	(
		imp = GroupImportTail()
	|
		imp = SingleImportTail()
	)
	{
		return imp;
	}
}

GroupImport GroupImportTail() :
{
	QID globalName;
	Import.Kind kind = Import.Kind.VAR;
}
{
	"all"
	(kind = ImportKind())?
	globalName = QID()
	{
		return new GroupImport(kind, globalName);
	}
}

SingleImport SingleImportTail() :
{
	QID globalName;
	Import.Kind kind = Import.Kind.VAR;
	Token localNameToken = null;
}
{
	(kind = ImportKind())?
	globalName = QID()
	("=" localNameToken = <ID>)?
	{
		String localName;
		if (localNameToken == null) {
			localName = globalName.getLast().toString();
		} else {
			localName = localNameToken.image;
		}
		return new SingleImport(kind, globalName, localName);
	}
}

Import.Kind ImportKind() :
{}
{
	"var" { return Import.Kind.VAR; }
|
	"type" { return Import.Kind.TYPE; }
|
	"entity" { return Import.Kind.ENTITY; }
}


GlobalEntityDecl NetworkDecl() :
{
	Token id;
	ImmutableList.Builder<ParameterTypeDecl> typePars = ImmutableList.builder();
	ImmutableList.Builder<ParameterVarDecl> valuePars = ImmutableList.builder();
	ImmutableList<PortDecl> inputPorts;
	ImmutableList<PortDecl> outputPorts;
	ImmutableList.Builder<LocalVarDecl> varDecls = ImmutableList.builder();
	ImmutableList.Builder<TypeDecl> typeDecls = ImmutableList.builder();
	ImmutableList<InstanceDecl> instances = ImmutableList.empty();
	ImmutableList<StructureStatement> structure = ImmutableList.empty();
	ImmutableList.Builder<Annotation> annotations = ImmutableList.builder();
    Annotation annotation;
	LocalVarDecl varDecl;
}
{
	( annotation = Annotation() {annotations.add(annotation);} )*
	"network"
	id = <ID>
	"("
	FormalParameters(typePars, valuePars)
	")"
	inputPorts = PortDecls()
	"==>"
	outputPorts = PortDecls()
	":"
	(
		"var"
		(
			varDecl = LocalVarDecl()
			{ varDecls.add(varDecl); }
		)*
	)?
	("entities" instances = EntityInstanceDecls())?
	("structure" structure = StructureStmts())?
	"end"


	{ return GlobalEntityDecl.global(Availability.PUBLIC, id.image, new NlNetwork(annotations.build(), typePars.build(), valuePars.build(), typeDecls.build(), varDecls.build(), inputPorts, outputPorts,
                 			instances, structure)); }
}

ImmutableList<ToolAttribute> OptToolAttributes() :
{
	ImmutableList.Builder<ToolAttribute> builder = ImmutableList.builder();
	Token id;
	Expression expression;
	TypeExpr type;
}
{
	(
	"{"
	(
		id = <ID>
		(
			":"
			type = Type()
			{
				builder.add(new ToolTypeAttribute(id.image, type));
			}
		|
			"="
			expression = Expression()
			{
				builder.add(new ToolValueAttribute(id.image, expression));
			}
		)
		";"
	)*
	"}"
	)?
	{
		return builder.build();
	}
}

ImmutableList<InstanceDecl> EntityInstanceDecls() :
{
	Token instanceName;
	EntityExpr expr;
	ImmutableList.Builder<InstanceDecl> entities = ImmutableList.builder();
}
{
	(

		instanceName = <ID>
		"="
		expr = ExprEntity()
		";"
		{
			entities.add(new InstanceDecl(instanceName.image, expr));
		}
	)*
	{
		return entities.build();
	}
}

EntityExpr ExprEntity() :
{
    EntityExpr expr;
}
{
    (
        expr = InstanceExprEntity()
    |
        expr = IfExprEntity()
    |
        expr = ListExprEntity()
    )
    {
        return expr;
    }

}

EntityInstanceExpr InstanceExprEntity() :
{
    EntityInstanceExpr expr;
    Token entityName;
    Token parameterName;
    Token last;
    Expression parameter;
    ImmutableList.Builder<ValueParameter> valueParameters;
    ImmutableList.Builder<TypeParameter> typeParameters;
    ImmutableList<ToolAttribute> toolAttrs;
}
{
        {
            valueParameters = ImmutableList.builder();
            typeParameters = ImmutableList.builder();
        }

        entityName = <ID>
        "("
        ParameterAssignments(typeParameters, valueParameters)
        last = ")"
        toolAttrs = OptToolAttributes()
    {
        return setPosition(new EntityInstanceExpr(new EntityReferenceLocal(entityName.image), typeParameters.build(), valueParameters.build()).withAttributes(toolAttrs), entityName, last);
    }
}

EntityIfExpr IfExprEntity() :
{
    Expression condition;
    EntityExpr trueEntity;
    EntityExpr falseEntity;
}
{
    "if"
    condition = Expression()
    "then"
    trueEntity = ExprEntity()
    "else"
    falseEntity = ExprEntity()
    "end"
    {
        return new EntityIfExpr(condition, trueEntity, falseEntity);
    }
}


ImmutableList<EntityExpr> EntityExprList():
{
	ImmutableList.Builder<EntityExpr> list = ImmutableList.builder();
	EntityExpr expr;
}
{
	(
		expr = ExprEntity()
		{ list.add(expr); }
		(
			","
			expr = ExprEntity()
			{ list.add(expr); }
		)*
	)?
	{
		return list.build();
	}
}

EntityComprehensionExpr EntityComprehensionFor(EntityExpr contents) :
{
	TypeExpr type = null;
	Token id;
	ImmutableList.Builder<GeneratorVarDecl> varDecls = ImmutableList.builder();
	Expression collection;
	Expression filter;
	ImmutableList.Builder<Expression> filters = ImmutableList.builder();
}
{
	"for"
	(
		LOOKAHEAD(Type() <ID>)
		type = Type()
	)?
	id = <ID>
	{
		varDecls.add(VarDecl.generator(id.image));
	}
	(
		","
		id = <ID>
		{
			varDecls.add(VarDecl.generator(id.image));
		}
	)*
	"in"
	collection = Expression()
	(
		LOOKAHEAD(2)
		","
		filter = Expression()
		{ filters.add(filter); }
	)*
	(
		","
		contents = EntityComprehensionFor(contents)
	)?
	{
		return new EntityComprehensionExpr(new Generator(type, varDecls.build(), collection), filters.build(), contents);
	}
}

EntityExpr ListExprEntity() :
{
    EntityExpr result;
	ImmutableList<EntityExpr> exprs;
}

{
	"["
	exprs = EntityExprList()
	{ result = new EntityListExpr(exprs); }
	(
		":"
		result = EntityComprehensionFor(exprs.size() == 1 ? exprs.get(0) : new EntityListExpr(exprs))
	)?
	"]"
	{
		return result;
	}

}


ImmutableList<StructureStatement> StructureStmts() :
{
    ImmutableList.Builder<StructureStatement> stmts = ImmutableList.builder();
    StructureStatement stmt;
}
{
    ( stmt = StructureStatement() { stmts.add(stmt); } )*
    { return stmts.build(); }
}


StructureStatement StructureStatement() :
{
	StructureStatement stmt;
}
{
    ( Annotation() )*
    (
        stmt = StructureConnectionStmt()
        |
        stmt = StructureIfStmt()
        |
        stmt = StructureForeachStmt()
    )
	{
		return stmt;
	}
}

StructureConnectionStmt StructureConnectionStmt():
{
    Token src, srcPort, tgt, tgtPort;
    PortReference sourcePort;
    PortReference targetPort;
	ImmutableList toolAttrs;
}
{
    sourcePort = EntityPort()
    "-->"
    targetPort = EntityPort()
    toolAttrs = OptToolAttributes()
    ";"
    {
        StructureConnectionStmt conn = new StructureConnectionStmt(sourcePort, targetPort).withAttributes(toolAttrs);
        conn = setPosition(conn, sourcePort, targetPort);
        return conn;
    }
}

PortReference EntityPort() :
{
    // Four temporary objects used for parsing but not for creating the AST nodes.
    Token idToken1 = null; // Stores the first encountered token
    ImmutableList<Expression> braces1 = null; // Stores the first encountered set of braces
    Token idToken2 = null; // Stores the second encountered token
    ImmutableList<Expression> braces2 = null; // Stores the second encountered set of braces

    // These variables are used to create the AST nodes. The get there values from the temporary variables above
    // based on logic described below.
    Token id = null;
    Token idPort = null;
    Expression portIndexExpr = null;
    ImmutableList<Expression> index;
}
{
    {id = null; index = ImmutableList.empty();}
    (
        idToken1 = <ID>
        braces1 = EntityIndexing()
        ("." idToken2 = <ID> braces2 = EntityIndexing())?
    )
    {
        // Note by @Gareth Callanan: This parsing got a bit convoluted with the intermediate tokens idToken1, idToken2
        // braces1, braces2 being used. The similarity between Port[...] and Entity[...]. Port created ambiguities when
        // parsing certain patterns ('Port[1+2+3]' is one such example that could not be solved with a large lookahead)
        // The current solution took a few rewrites to get correct, but it now works. There could be more elegant
        // solutions out there.

        // If idToken2 is not null then we expect that this EntityPort is of form:
        // EntityName[EntityIndex].PortName[PortIndex] (with '[EntityIndex]' and
        // '[PortIndex]' being optional).
        //
        // If idToken2 is null, then we expect that this EntityPort is of form:
        // PortName[PortIndex] ('[PortIndex]' being optional)
        if(idToken2 != null){
            id = idToken1;
            idPort = idToken2;
            index = braces1;
            if(braces2.size() == 1){
                portIndexExpr = braces2.get(0);
            }else if (braces2.size() > 1){
                // Note by @Gareth Callanan: when I use throw ParseException(...) instead of generateParseException()
                // the error message thrown is unintelligible. However, with generateParseException() I cannot create a
                // custom  error message. This println is the simplest compromise I have for now.
                System.out.println("ERROR: A port array may only have one set of braces - the current port has '" + braces2.size() + "' sets. Arrays of arrays are not supported");
                throw generateParseException();
            }
        }else{
            idPort = idToken1;
            if(braces1.size() == 1){
                portIndexExpr = braces1.get(0);
            }else if (braces1.size() > 1){
                // Note by @Gareth Callanan: when I use throw ParseException(...) instead of generateParseException()
                // the error message thrown is unintelligible. However with generateParseException() I cannot create a
                // custom  error message. This println is the simplest compromise I have for now.
                System.out.println("ERROR: A port array may only have one set of braces - the current port has '" + braces1.size() + "' sets. Arrays of arrays are not supported");
                throw generateParseException();
            }
        }

        ImmutableList.Builder<Expression> portIndex = ImmutableList.builder();
        if(portIndexExpr != null){
            portIndex.add(portIndexExpr);
        }

        PortReference portRef = new PortReference(id == null ? null : id.image, id == null ? ImmutableList.empty() : index, idPort.image, portIndex.build());
        portRef = setPosition(portRef, id == null ? idPort : id, idPort);
        return portRef;
    }
}

ImmutableList<Expression> EntityIndexing() :
{
    ImmutableList.Builder<Expression> entityIndex = ImmutableList.builder();
    Expression expr;
}
{
    (
        "["
        expr = Expression()
        "]"
        {
            entityIndex.add(expr);
        }
    )*
    {
        return entityIndex.build();
    }
}

StructureIfStmt StructureIfStmt():
{
	Expression cond;
	ImmutableList<StructureStatement> thenStmts;
	ImmutableList<StructureStatement> elseStmts = null;
}
{
	"if"
	cond = Expression()
	"then"
	thenStmts = StructureStmts()
	(
		elseStmts = StructureElseIfStmt()
	|
		"else"
		elseStmts = StructureStmts()
	)?
	"end"
	{
		return new StructureIfStmt(cond, thenStmts, elseStmts);
	}
}


ImmutableList<StructureStatement> StructureElseIfStmt() :
{
	Expression cond;
	StructureStatement thenStmt;
	ImmutableList<StructureStatement> thenStmts;
	StructureStatement elseStmt;
	ImmutableList<StructureStatement> elseStmts = null;
}
{
	"elsif"
	cond = Expression()
	"then"
	thenStmts = StructureStmts()
	(
		elseStmts = StructureElseIfStmt()
	|
		"else"
		elseStmts = StructureStmts()
	)?
	{
		return ImmutableList.of(new StructureIfStmt(cond, thenStmts, elseStmts));
	}
}

StructureForeachStmt StructureForeachStmt() :
{
	StructureForeachStmt stmt;
}
{
	stmt = StructureForeachStmtHeader()
	"end"
	{
		return stmt;
	}
}

StructureForeachStmt StructureForeachStmtHeader() :
{
	TypeExpr type = null;
	Token id;
	ImmutableList.Builder<GeneratorVarDecl> varDecls = ImmutableList.builder();
	Expression collection;
	Expression filter;
	ImmutableList.Builder<Expression> filters = ImmutableList.builder();
	ImmutableList<StructureStatement> body;
}
{
	"foreach"
	(
		LOOKAHEAD(2)
		type = Type()
	)?
	id = <ID>
	{ varDecls.add(VarDecl.generator(id.image)); }
	(
		","
		id = <ID>
		{ varDecls.add(VarDecl.generator(id.image)); }
	)*
	"in"
	 collection = Expression()
	(
		LOOKAHEAD(2)
		","
		filter = Expression()
		{ filters.add(filter); }
	)*
	body = StructureForeachStmtBody()
	{
		return new StructureForeachStmt(new Generator(type, varDecls.build(), collection), filters.build(), body);
	}
}

ImmutableList<StructureStatement> StructureForeachStmtBody() :
{
	StructureStatement result;
	ImmutableList<StructureStatement> stmts;
}
{
	"," result = StructureForeachStmtHeader()
	{
		return ImmutableList.of(result);
	}
|
	"do"
	stmts = StructureStmts()
	{
        return stmts;
	}
}

/* ActorDecl */
GlobalEntityDecl ActorDecl() :
{
	Token id;
	String name;
	boolean external = false;
	ImmutableList.Builder<Annotation> annotations = ImmutableList.builder();
	Annotation annotation;
	ImmutableList.Builder<ParameterTypeDecl> typePars = ImmutableList.builder();
	ImmutableList.Builder<ParameterVarDecl> valuePars = ImmutableList.builder();
	ImmutableList<TypeDecl> typeDecls = ImmutableList.empty();
	ImmutableList.Builder<LocalVarDecl> varDecls = ImmutableList.builder();
	LocalVarDecl varDecl;
	ImmutableList<PortDecl> inputPorts = ImmutableList.empty();
	ImmutableList<PortDecl> outputPorts = ImmutableList.empty();
	ImmutableList.Builder<Action> initializers = ImmutableList.builder();
	ImmutableList.Builder<Action> actions = ImmutableList.builder();
	Action action;
	ImmutableList.Builder<ActionCase> actionCases = ImmutableList.builder();
    ActionCase actionCase;
	ScheduleFSM scheduleFSM = null;
	RegExp scheduleRegExp = null;
	ProcessDescription process = null;
	ImmutableList.Builder<ImmutableList<QID>> priorities = ImmutableList.builder();
	ImmutableList<Expression> invariants = ImmutableList.empty();
    ActionGeneratorStmt actionGeneratorStmt;
    ImmutableList.Builder<ActionGeneratorStmt> actionGeneratorStmts = ImmutableList.builder();
	int beginLine;
    int beginColumn;
}
{
	( annotation = Annotation() {annotations.add(annotation);} )*
	("external" {external = true;})?
	"actor"
	{
	    beginLine = token.beginLine;
	    beginColumn = token.beginColumn;
	}
	id = <ID> { name = id.image; }
	"("
	FormalParameters(typePars, valuePars)
	")"
	inputPorts = PortDecls()
	"==>"
	outputPorts = PortDecls()
	("time" Type())?
	(
		":"
		(
			(
				LOOKAHEAD(( Annotation() )* (QID() ":")? "action" "case")
				actionCase = ActionCase(inputPorts, outputPorts)
				{ actionCases.add(actionCase); }
			|
				LOOKAHEAD( ( Annotation() )* (QID() ":")? "action")
				action = Action(inputPorts, outputPorts)
				{ actions.add(action); }
			|
				LOOKAHEAD( ( Annotation() )* (QID() ":")? "initialize")
				action = InitializationAction(outputPorts)
				{ initializers.add(action); }
			|
				varDecl = LocalVarDecl()
				{ varDecls.add(varDecl); }

            |
                invariants = Invariants()
			|
				PriorityOrder(priorities)
			|
				{
					if (scheduleFSM != null || process != null) {
						throw new ParseException("Only one action schedule or process description is allowed.");
					}
				}
				scheduleFSM = ActionSchedule()
			|
			    scheduleRegExp = ActionScheduleRegExp()
			    {
			        if (scheduleFSM != null && scheduleRegExp != null) {
                        throw new ParseException("Either a schedule fsm or schedule regexp can be defined.");
                    }
			    }
			|
				{
					if (scheduleFSM != null || process != null) {
						throw new ParseException("Only one action schedule or process description is allowed.");
					}
				}
				process = ProcessDescription()
			|
			    actionGeneratorStmt = ActionGeneratorStmt(inputPorts, outputPorts)
			    { actionGeneratorStmts.add(actionGeneratorStmt) ;}
			)
		)*
		("end" | "endactor")
	|
		";"
	)
	{
		CalActor a = new CalActor(annotations.build(), typePars.build(), valuePars.build(), typeDecls, varDecls.build(), inputPorts, outputPorts, initializers.build(), actions.build(), actionCases.build(), actionGeneratorStmts.build(), scheduleFSM, scheduleRegExp, process, priorities.build(), invariants);
		a.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
		return GlobalEntityDecl.global(Availability.PUBLIC, name, a, external);
	}
}

ProcessDescription ProcessDescription() :
{
	ImmutableList<Statement> statements;
	boolean repeated;
}
{
	(
		"repeat"
		{ repeated = true; }
	|
		"do"
		{ repeated = false; }
	)
	{
		processDescription = true;
	}
	statements = Statements()
	"end"
	{
		processDescription = false;
		return new ProcessDescription(statements, repeated);
	}
}

ImmutableList<PortDecl> PortDecls() :
{
	ImmutableList.Builder<PortDecl> decls = ImmutableList.builder();
	PortDecl decl;
}
{
	(
		decl = PortDecl() { decls.add(decl); }

		(
			","
			decl = PortDecl() { decls.add(decl); }
		)*
	)?
	{ return decls.build(); }
}

PortDecl PortDecl() :
{
	TypeExpr type = null;
	Token id;
    Expression expr = null;
}
{
	(
		Annotation()
	)*
	(
		LOOKAHEAD(2)
		type = Type()
		id = <ID>
	|
		id = <ID>
	)
	(
	"["
        expr = Expression()
    "]"
    )?
    {
            PortDecl port = new PortDecl(id.image, type, expr);
            port.setPosition(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
            return port;
    }

}

/* Actions */

Action Action(ImmutableList<PortDecl> inputs, ImmutableList<PortDecl> outputs) :
{
	QID tag = null;
	ImmutableList.Builder<Annotation> annotations = ImmutableList.builder();
	Annotation annotation;
	ImmutableList<InputPattern> inputPatterns;
	ImmutableList<OutputExpression> outputExpressions;
	ImmutableList<TypeDecl> typeDecls = ImmutableList.empty();
	ImmutableList<LocalVarDecl> varDecls = ImmutableList.empty();
	ImmutableList<Expression> guards = ImmutableList.empty();
	ImmutableList<Statement> body = ImmutableList.empty();
	Expression delay = null;
	ImmutableList<Expression> preconditions = ImmutableList.empty();
	ImmutableList<Expression> postconditions = ImmutableList.empty();

	int beginLine;
    int beginColumn;
}
{
	( annotation = Annotation() {annotations.add(annotation);} )*
	( tag = QID() ":" )?
	"action"
	{
	    beginLine = token.beginLine;
	    beginColumn = token.beginColumn;
	}
	inputPatterns = InputPatterns(inputs)
	"==>"
	outputExpressions = OutputExpressions(outputs)
	("guard" guards = ExpressionList())?
//	("delay" delay = Expression())?
	("var" varDecls = BlockVarDecls())?
	("do" body = Statements())?
	("end" | "endaction")
	{
		Action action = new Action(tag, annotations.build(), inputPatterns, outputExpressions, typeDecls, varDecls, guards, body, delay, preconditions, postconditions);
		action.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
		return action;
	}
}

ActionCase ActionCase(ImmutableList<PortDecl> inputs, ImmutableList<PortDecl> outputs) :
{
  QID tag = null;
  Action action;
  ImmutableList.Builder<Action> actions = ImmutableList.builder();
  ImmutableList.Builder<Annotation> annotations = ImmutableList.builder();
  Annotation annotation;

  int beginLine;
  int beginColumn;
}
{
  ( annotation = Annotation() {annotations.add(annotation);} )*
  ( tag = QID() ":" )?
  "action"
  {
    beginLine = token.beginLine;
    beginColumn = token.beginColumn;
  }
  "case"
  action = ActionLambda(annotations.build(), inputs, outputs) { actions.add(action); }
  (
    "else"
    action = ActionLambda(annotations.build(), inputs, outputs) { actions.add(action); }
  )+
  ( "end" | "endcase")
  ( "end" | "endaction")
  {
    ActionCase actionCase = new ActionCase(tag, actions.build());
    actionCase.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
    return actionCase;
  }
}

Action ActionLambda(ImmutableList<Annotation> annotations, ImmutableList<PortDecl> inputs, ImmutableList<PortDecl> outputs) :
{
  QID tag = null;
  ImmutableList<InputPattern> inputPatterns;
  ImmutableList<OutputExpression> outputExpressions;
  ImmutableList<TypeDecl> typeDecls = ImmutableList.empty();
  ImmutableList<LocalVarDecl> varDecls = ImmutableList.empty();
  ImmutableList<Expression> guards = ImmutableList.empty();
  ImmutableList<Statement> body = ImmutableList.empty();
  Expression delay = null;
  ImmutableList<Expression> preconditions = ImmutableList.empty();
  ImmutableList<Expression> postconditions = ImmutableList.empty();
  int beginLine;
  int beginColumn;
}
{
  {
    beginLine = token.beginLine;
    beginColumn = token.beginColumn;
  }

  inputPatterns = InputPatterns(inputs)
  "==>"
  outputExpressions = OutputExpressions(outputs)
  ("guard" guards = ExpressionList())?
//  ("delay" delay = Expression())?
  ("var" varDecls = BlockVarDecls())?
  ("do" body = Statements())?
  ("end")
  {
    Action action = new Action(tag, annotations, inputPatterns, outputExpressions, typeDecls, varDecls, guards, body, delay, preconditions, postconditions);
    action.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
    return action;
  }
}

Action InitializationAction(ImmutableList<PortDecl> outputs) :
{
	QID tag = null;
	ImmutableList.Builder<Annotation> annotations = ImmutableList.builder();
	Annotation annotation;
	ImmutableList<InputPattern> inputPatterns = ImmutableList.empty();
	ImmutableList<OutputExpression> outputExpressions;
	ImmutableList<TypeDecl> typeDecls = ImmutableList.empty();
	ImmutableList<LocalVarDecl> varDecls = ImmutableList.empty();
	ImmutableList<Expression> guards = ImmutableList.empty();
	ImmutableList<Statement> body = ImmutableList.empty();
	Expression delay = null;
	ImmutableList<Expression> preconditions = ImmutableList.empty();
	ImmutableList<Expression> postconditions = ImmutableList.empty();
	int beginLine;
    int beginColumn;
}
{
	( annotation = Annotation() {annotations.add(annotation);} )*
	( tag = QID() ":" )?
	"initialize"
	{
        beginLine = token.beginLine;
        beginColumn = token.beginColumn;
    }
	"==>"
	outputExpressions = OutputExpressions(outputs)
	("guard" guards = ExpressionList())?
	("var" varDecls = BlockVarDecls())?
//	("delay" delay = Expression())?
	("do" body = Statements())?
	("end" | "endinitialize")
	{
		Action action = new Action(tag, annotations.build(), inputPatterns, outputExpressions, typeDecls, varDecls, guards, body, delay, preconditions, postconditions);
		action.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
		return action;
	}
}

ImmutableList<InputPattern> InputPatterns(ImmutableList<PortDecl> ports) :
{
	ImmutableList.Builder<InputPattern> builder = ImmutableList.builder();
	InputPattern in;
	int position = 0;
}
{
	(
		in = InputPattern(ports, position) { builder.add(in); position++;}
		("," in = InputPattern(ports, position) { builder.add(in); position++; })*
	)?
	{ return builder.build(); }
}

ActionGeneratorStmt ActionGeneratorStmt(ImmutableList<PortDecl> inputPorts, ImmutableList<PortDecl> outputPorts) :
{
    TypeExpr type = null;
    Token id;
    ImmutableList.Builder<GeneratorVarDecl> varDecls = ImmutableList.builder();
    Expression collection;
    Expression filter;
    Action action;
    ActionCase actionCase;
    ActionGeneratorStmt actionGeneratorStmt;
    ImmutableList.Builder<Expression> filters = ImmutableList.builder();

    ImmutableList.Builder<Action> actions = ImmutableList.builder();
    ImmutableList.Builder<ActionCase> actionCases = ImmutableList.builder();
    ImmutableList.Builder<ActionGeneratorStmt> actionGeneratorStmts = ImmutableList.builder();

    int beginLine;
    int beginColumn;
}
{
    "foreach"
    {
        beginLine = token.beginLine;
        beginColumn = token.beginColumn;
    }
    (
        LOOKAHEAD(Type() <ID>)
        type = Type()
    )?
    id = <ID>
    {
        varDecls.add(VarDecl.generator(id.image));
    }
    (
        ","
        id = <ID>
        {
            varDecls.add(VarDecl.generator(id.image));
        }
    )*
    "in"
    collection = Expression()
    (
        LOOKAHEAD(2)
        ","
        filter = Expression()
        { filters.add(filter); }
    )*
    "generate"
    (
        (
            LOOKAHEAD(( Annotation() )* (QID() ":")? "action" "case")
            actionCase = ActionCase(inputPorts, outputPorts)
            { actionCases.add(actionCase); }
        |
            LOOKAHEAD( ( Annotation() )* (QID() ":")? "action")
            action = Action(inputPorts, outputPorts)
            { actions.add(action); }
        |
            actionGeneratorStmt = ActionGeneratorStmt(inputPorts, outputPorts)
            { actionGeneratorStmts.add(actionGeneratorStmt) ;}
        )
    )*
    "end"
    {
        ActionGeneratorStmt actionGeneratorStmtRet = new ActionGeneratorStmt(new Generator(type, varDecls.build(), collection), filters.build(), actions.build(), actionCases.build(), actionGeneratorStmts.build());
        actionGeneratorStmtRet.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
        return actionGeneratorStmtRet;
    }
}

InputPattern InputPattern(ImmutableList<PortDecl> ports, int position) :
{
	Token id = null;
	Port port = null;
	Match match;
	ImmutableList.Builder<Match> matches = ImmutableList.builder();
    Expression portIndexExpr = null;
	Expression repeat = null;
	int beginLine = 0;
    int beginColumn = 0;
}
{
	( id = <ID>
        (
        "["
        portIndexExpr = Expression()
        "]"
        )?
        ":"
        {
            if(id != null){
                beginLine = id.beginLine;
                beginColumn = id.beginColumn;
            } else{
                beginLine = token.beginLine;
                beginColumn = token.beginColumn;
            }
            port = new Port(id.image);
        }
    )?

	"["
	(
		match = Match() { matches.add(match); }
		("," match = Match() { matches.add(match); } )*
	)?
	"]"
	("repeat" repeat = Expression())?
	{
        Port portResolution = port == null ? new Port(ports.get(position).getName()) : port;
        InputPattern inputPattern = new InputPattern(portResolution, matches.build(), repeat, portIndexExpr);
        inputPattern.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
        return inputPattern;
    }
}

Match Match() :
{
    Pattern pattern;
}
{

    pattern = Pattern()
    {
        InputVarDecl declaration = new InputVarDecl();
        Expression expression = setPosition(new ExprVariable(Variable.variable(declaration.getName())), pattern, pattern);
        ExprCase.Alternative alternative = setPosition(new ExprCase.Alternative(pattern, Collections.emptyList(), new ExprLiteral(ExprLiteral.Kind.True)), pattern, pattern);
        ExprCase.Alternative otherwise = new ExprCase.Alternative(new PatternWildcard(), Collections.emptyList(), new ExprLiteral(ExprLiteral.Kind.False));
        ExprCase casee = setPosition(new ExprCase(expression, Arrays.asList(alternative, otherwise)), pattern, pattern);
        return setPosition(new Match(declaration, casee), pattern, pattern);
    }
}

ImmutableList<OutputExpression> OutputExpressions(ImmutableList<PortDecl> ports) :
{
	ImmutableList.Builder<OutputExpression> builder = ImmutableList.builder();
	OutputExpression out;
	int position = 0;
}
{
	(
		out = OutputExpression(ports, position) { builder.add(out); position++;}
		("," out = OutputExpression(ports, position) { builder.add(out); position++;})*
	)?
	{ return builder.build(); }
}

OutputExpression OutputExpression(ImmutableList<PortDecl> ports, int position) :
{
	Token first;
	Token last;
	Token id = null;
    Port port = null;
	ImmutableList<Expression> exprs;
    Expression portIndexExpr = null;
	Expression repeat = null;
}
{
	( id = <ID>
	(
        "["
        portIndexExpr = Expression()
        "]"
    )?
	":"
	{ port = new Port(id.image); })?
	first = "["
	exprs = ExpressionList()
	last = "]"
	( "repeat" repeat = Expression() )?
	{
        Port portResolution = port == null ? new Port(ports.get(position).getName()) : port;
        OutputExpression out = new OutputExpression(portResolution, exprs, repeat, portIndexExpr);
        if (port != null) { first = id; }
        if (repeat != null) {
            return setPosition(out, first, repeat);
        } else {
            return setPosition(out, first, last);
        }
	}
}

ImmutableList<Expression> Invariants() :
{
    ImmutableList<Expression> exprs = ImmutableList.empty();
}
{
    "invariant"
    exprs = ExpressionList()
    ("end" | "endinvariant")
    {
            return exprs;
    }
}
/* Action control */
ScheduleFSM ActionSchedule() :
{
	Token init;
	ImmutableList<Transition> trans;
	int beginLine = 0;
    int beginColumn = 0;
}
{
	"schedule fsm"
	{
	    beginLine = token.beginLine;
	    beginColumn = token.endColumn;
	}

	init = <ID>
	":"
	trans = StateTransitions()
	("end" | "endschedule")
	{
        ScheduleFSM fsm = new ScheduleFSM(trans, init.image);
        fsm.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
        return fsm;
    }
}

RegExp ActionScheduleRegExp():
{
    Token init;
    RegExp regExp = null;
	int beginLine = 0;
    int beginColumn = 0;
}
{
    "schedule regexp"
	{
	    beginLine = token.beginLine;
	    beginColumn = token.endColumn;
	}

	regExp = RegExp()
	("end" | "endschedule")
	{
        regExp.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
        return regExp;
	}
}

RegExp RegExp():
{
    RegExp regExp;
    String op = "";
    ImmutableList.Builder<String> ops = ImmutableList.builder();
    ImmutableList.Builder<RegExp> exprs = ImmutableList.builder();
}
{
    regExp = UnaryOperationRegExp() {exprs.add(regExp);}
    (
        ("|" {op="|";} )?
        regExp = UnaryOperationRegExp()
        { ops.add(op); exprs.add(regExp); op ="";}
    )*
    {
        ImmutableList<String> opList = ops.build();
        ImmutableList<RegExp> exprList = exprs.build();
        if (opList.isEmpty()) {
            return regExp;
        } else {
            return setPosition(new RegExpBinary(opList, exprList), exprList.get(0), exprList.get(exprList.size()-1));
        }
    }
}

RegExp RegExpTag():
{
    Token init;
	int beginLine = 0;
    int beginColumn = 0;
    QID qid;
}
{
    {
    	    beginLine = token.beginLine;
    	    beginColumn = token.endColumn;
    }

    qid = QID()

    {
        RegExpTag regExp = new RegExpTag(qid);
        regExp.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
        return regExp;
    }
}


RegExp UnaryOperationRegExp():
{
    String op = null;
    RegExp regExp;
    Token init;
    int beginLine = 0;
    int beginColumn = 0;
}
{
    {
        beginLine = token.beginLine;
        beginColumn = token.endColumn;
    }

    regExp = SingleRegExpExpression()
    (op = UnaryRegExpOperation())?

    {
        if(op == null){
            return regExp;
        }

        regExp = new RegExpUnary(op, regExp);
        regExp.setPosition(beginLine, beginColumn, token.endLine, token.endColumn);
        return regExp;
    }
}

RegExp SingleRegExpExpression():
{
    RegExp regExp;
}
{
    (
        regExp = RegExpTag()
        |
        "(" regExp = RegExp() ")")
    {
        return regExp;
    }
}

ImmutableList<Transition> StateTransitions() :
{
	ImmutableList.Builder<Transition> builder = ImmutableList.builder();
}
{
	(StateTransition(builder) ";")*
	{ return builder.build(); }
}

void StateTransition(ImmutableList.Builder<Transition> builder) :
{
	Token src;
	Token dst;
	QID qid;
	ImmutableList.Builder<QID> tags = ImmutableList.builder();
}
{
	src = <ID>
	"("
	qid = QID() { tags.add(qid); }
	( "," qid = QID() { tags.add(qid); } )*
	")"
	"-->"
	dst = <ID>
	{ builder.add(new Transition(src.image, dst.image, tags.build())); }
	(
		{ tags = ImmutableList.builder(); }
		"|"
		"("
		qid = QID() { tags.add(qid); }
		("," qid = QID() { tags.add(qid); } )*
		")"
		"-->"
		dst = <ID>
		{ builder.add(new Transition(src.image, dst.image, tags.build())); }
	)*
}

void PriorityOrder(ImmutableList.Builder<ImmutableList<QID>> prio) :
{
	ImmutableList.Builder<QID> seq;
	QID qid;
}
{
	"priority"
	(
		{ seq = ImmutableList.builder(); }
		qid = QID() { seq.add(qid); }
		">"
		qid = QID() { seq.add(qid); }
		(
			">"
			qid = QID() { seq.add(qid); }
		)*
		";"
		{ prio.add(seq.build()); }
	)*
	"end"
}

/* Expressions */

Expression Expression() :
{
	Expression expr;
	String op;
	ImmutableList.Builder<String> ops = ImmutableList.builder();
	ImmutableList.Builder<Expression> exprs = ImmutableList.builder();
}
{
	expr = UnaryOperation() { exprs.add(expr); }
	(
		op = BinaryOperator()
		expr = UnaryOperation()
		{ ops.add(op); exprs.add(expr); }
	)*
	{
		ImmutableList<String> opList = ops.build();
		ImmutableList<Expression> exprList = exprs.build();
		if (opList.isEmpty()) {
			return expr;
		} else {
			return setPosition(new ExprBinaryOp(opList, exprList), exprList.get(0), exprList.get(exprList.size()-1));
		}
	}
}

Expression UnaryOperation() :
{
	String op;
	List<String> ops = new ArrayList<String>();
	Expression expr;
}
{
	(
		op = UnaryOperator()
		{ ops.add(op); }
	)*
	expr = PrimaryExpression()
	{
		Collections.reverse(ops);
		for (String o : ops) {
			expr = new ExprUnaryOp(o, expr);
		}
		return expr;
	}
}

Expression PrimaryExpression() :
{
	Expression expr;
	ImmutableList<Expression> args;
	Expression index;
	Field field;
	Nth nth;
	Token decimal;
	Token lastToken;
	ImmutableList.Builder<TypeParameter> typeParameters = ImmutableList.builder();
	ImmutableList.Builder<ValueParameter> valueParameters = ImmutableList.builder();
}
{
	expr = SingleExpression()
	{ exprIsVar = expr instanceof ExprVariable; }
	(
		(
			LOOKAHEAD("(" ParameterAssignment())
			"("
        ParameterAssignment(typeParameters, valueParameters)
        ( "," ParameterAssignment(typeParameters, valueParameters) )*
			")"
		)?
		"("
		args = ExpressionList()
		lastToken = ")"
		{
			List<TypeParameter> types = typeParameters.build();
			List<ValueParameter> values = valueParameters.build();
			if (types.isEmpty() && values.isEmpty()) {
				expr = setPosition(new ExprApplication(expr, args), expr, lastToken);
			} else {
				expr = setPosition(new ExprTypeConstruction(((ExprVariable) expr).getVariable().getName(), types, values, args), expr, lastToken);
			}
	}
	|
		"["
			index = Expression()
		{ expr = new ExprIndexer(expr, index); }
		(
			","
			index = Expression()
			{ expr = new ExprIndexer(expr, index); }
		)*
		"]"
 	|
		LOOKAHEAD(<DOT_SHARP>)
		<DOT_SHARP> nth = Nth()
		{
			expr = setPosition(new ExprNth(expr, nth), expr, nth);
		}
	|
		"." field = Field()
		{ expr = setPosition(new ExprField(expr, field), expr, field); }
	)*
	{
		return expr;
	}
}

Expression SingleExpression() :
{
	Expression expr;
}
{
	(
		expr = VariableExpression()
	|
		expr = ExpressionLiteral()
	|
		LOOKAHEAD(TypeAssertionExpression())
		expr = TypeAssertionExpression()
  |
    LOOKAHEAD(TupleExpression())
		expr = TupleExpression()
	|
		"(" expr = Expression() ")"
		{expr.setHasParenthesis(true);}
	|
		expr = CaseExpression()
	|
		expr = IfExpression()
	|
		expr = LambdaExpression()
	|
		expr = ProcExpression()
	|
		expr = LetExpression()
	|
		expr = ListExpression()
	|
		expr = SetExpression()
	|
		expr = MapExpression()
	)
	{return expr; }
}

ExprVariable VariableExpression() :
{
	Variable var;
	boolean old = false;
}
{
	("old" {old = true;})?  var = Variable()
	{
		return setPosition(new ExprVariable(var, old), var, var);
	}
}

Variable Variable() :
{
	Token id;
}
{
	id = <ID>
	{
		return setPosition(Variable.variable(id.image), id, id);
	}
}

ExprLiteral ExpressionLiteral() :
{
	Token lit;
	ExprLiteral result = null;
}
{
	(
		lit = <INTEGER> { result = new ExprLiteral(ExprLiteral.Kind.Integer, lit.image); }
	|
		lit = <REAL> { result = new ExprLiteral(ExprLiteral.Kind.Real, lit.image); }
    |
        lit = <COMPLEX_REAL> { result = new ExprLiteral(ExprLiteral.Kind.Complex_Real, lit.image); }
	|
        lit = <COMPLEX_INT> { result = new ExprLiteral(ExprLiteral.Kind.Complex_Int, lit.image); }
    |
		lit = <TRUE> { result = new ExprLiteral(ExprLiteral.Kind.True); }
	|
		lit = <FALSE> { result = new ExprLiteral(ExprLiteral.Kind.False); }
	|
		lit = <NULL> { result = new ExprLiteral(ExprLiteral.Kind.Null); }
	|
	    lit = <CHARACTER_LITERAL> { result = new ExprLiteral(ExprLiteral.Kind.Char, lit.image); }
	|
		lit = <STRING_LITERAL> { result = new ExprLiteral(ExprLiteral.Kind.String, lit.image); }
	)
	{
		result.setPosition(lit.beginLine, lit.beginColumn, lit.endLine, lit.endColumn);
		return result;
	}
}

ExprTypeAssertion TypeAssertionExpression() :
{
    Token first;
    Token last;
    Expression expression;
	TypeExpr type;
}
{
    first = "("
	expression = Expression()
    "as"
    type = Type()
    last = ")"
    { return setPosition(new ExprTypeAssertion(expression, type), first, last); }
}

ImmutableList<Expression> ExpressionList() :
{
	ImmutableList.Builder<Expression> list = ImmutableList.builder();
	Expression expr;
}
{
	(
		expr = Expression()
		{ list.add(expr); }
		(
			","
			expr = Expression()
			{ list.add(expr); }
		)*
	)?
	{
		return list.build();
	}
}

String BinaryOperator() :
{
	Token op;
}
{
	(
		op = <OP> | op = "=" | op = "-->" | op = ">" | op = "|" | op = "*" | op = ".*" // | op = "@" | "->"
		| op = "and" | op = "or" | op = "in" | op = "div" | op = "mod"
	)
	{ return op.image; }
}

String UnaryOperator() :
{
	Token op;
}
{
	(
		op = <OP> | op = "=" | op = "-->" | op = "->" | op = ">" | op = "|" | op = "*" | op = ".*" // | op = "@"
		| op = "not" | op = "dom" | op = "rng" | op = "#"
	)
	{ return op.image; }
}

String UnaryRegExpOperation() :
{
    Token op;
}
{
    ( op = "*" | op = <OP> )
    {return op.image;}
}

ExprCase CaseExpression() :
{
    Token first;
    Token last;
    Expression scrutinee;
    ExprCase.Alternative alternative;
    ImmutableList.Builder<ExprCase.Alternative> alternatives = ImmutableList.builder();
}
{
    first = "case"
    scrutinee = Expression()
    "of"
    (
        alternative = CaseExprAlternative() { alternatives.add(alternative); }
        (
            alternative = CaseExprAlternative() { alternatives.add(alternative); }
        )*
    )?
    last = "end"
    { return setPosition(new ExprCase(scrutinee, alternatives.build()), first, last); }
}

ExprCase.Alternative CaseExprAlternative() :
{
    Pattern pattern;
    Expression guard;
    ImmutableList.Builder<Expression> guards = ImmutableList.builder();
    Expression expression;
    Token last;
}
{
    pattern = Pattern()
    (
        "guard"
        guard = Expression() { guards.add(guard); }
        (
            "," guard = Expression() { guards.add(guard); }
        )*
    )?
    ":"
    expression = Expression()
    last = "end"
    { return setPosition(new ExprCase.Alternative(pattern, guards.build(), expression), pattern, last); }
}

Pattern Pattern() :
{
	Pattern pattern;
}
{
	(
		LOOKAHEAD((PatternLiteral() | PatternExpression()) "|")
		pattern = PatternAlternative()
	|
		LOOKAHEAD(PatternDeclaration() <AS>)
		pattern = PatternAlias()
	|
		LOOKAHEAD(<ID> "(")
		pattern = PatternDeconstruction()
	|
		pattern = PatternTuple()
	|
		pattern = PatternList()
	|
		pattern = PatternLiteral()
	|
		pattern = PatternExpression()
	|
		pattern = PatternDeclaration()
	)
	{ return pattern; }
}

PatternDeclaration PatternDeclaration() :
{
	Token id;
}
{
	id = <ID>
	{
		if (token.image.equals("_")) {
			return setPosition(new PatternWildcard(), id, id);
		} else {
			return setPosition(new PatternBinding(setPosition(new PatternVarDecl(id.image), id, id)), id, id);
		}
	}
}

PatternAlternative PatternAlternative() :
{
  Pattern pattern;
  Pattern first;
  Pattern last;
  ImmutableList.Builder<Pattern> patterns = ImmutableList.builder();
}
{
  (
    pattern = PatternLiteral() { patterns.add(pattern); first = pattern; }
  |
    pattern = PatternExpression() { patterns.add(pattern); first = pattern; }
  )
  (
    "|"
    (
      pattern = PatternLiteral() { patterns.add(pattern); last = pattern; }
    |
      pattern = PatternExpression() { patterns.add(pattern); last = pattern; }
    )
  )+
  { return setPosition(new PatternAlternative(patterns.build()), first, last); }
}

PatternAlias PatternAlias() :
{
	Pattern alias;
	PatternExpression expression;
}
{
	alias = PatternDeclaration()
	<AS>
	expression = PatternExpression()
	{ return setPosition(new PatternAlias(alias, expression.getExpression()), alias, expression); }
}

PatternList PatternList() :
{
	Token first;
	Token last;
	Pattern pattern;
	ImmutableList.Builder<Pattern> patterns = ImmutableList.builder();
}
{
	first = "["
	(
		pattern = Pattern() { patterns.add(pattern); }
		(
			"," pattern = Pattern() { patterns.add(pattern); }
		)*
	)?
	last = "]"
	{ return setPosition(new PatternList(patterns.build()), first, last); }
}

PatternLiteral PatternLiteral() :
{
	ExprLiteral literal;
}
{
	literal = ExpressionLiteral()
	{ return setPosition(new PatternLiteral(literal), literal, literal); }
}

PatternExpression PatternExpression() :
{
	Token first;
	Token last;
	Expression expression;
}
{
  first = "`"
  (
    "("
    expression = Expression()
    last = ")"
    { return setPosition(new PatternExpression(expression), first, last); }
  |
    expression = VariableExpression()
    { return setPosition(new PatternExpression(expression), first, expression); }
  )
}

PatternDeconstruction PatternDeconstruction() :
{
	Token id;
	Token last;
	Pattern pattern;
	ImmutableList.Builder<TypeParameter> types = ImmutableList.builder();
	ImmutableList.Builder<ValueParameter> vals = ImmutableList.builder();
	ImmutableList.Builder<Pattern> patterns = ImmutableList.builder();
}
{
	id = <ID>
	(
		LOOKAHEAD("(" ParameterAssignment())
    "("
        ParameterAssignment(types, vals)
        ( "," ParameterAssignment(types, vals) )*
		")"
	)?
	"("
	(
		pattern = Pattern() { patterns.add(pattern); }
		(
			"," pattern = Pattern() { patterns.add(pattern); }
		)*
	)?
	last = ")"
	{ return setPosition(new PatternDeconstruction(id.image, types.build(), vals.build(), patterns.build()), id, last); }
}

PatternTuple PatternTuple() :
{
	Token first;
	Token last;
	Pattern pattern;
	ImmutableList.Builder<Pattern> patterns = ImmutableList.builder();
}
{
	first = "("
	pattern = Pattern() { patterns.add(pattern); }
	(
		"," pattern = Pattern() { patterns.add(pattern); }
	)+
	last = ")"
	{ return setPosition(new PatternTuple(patterns.build()), first, last); }
}

ExprIf IfExpression() :
{
	Expression cond;
	Expression thenExpr;
	Expression elseExpr;
}
{
	"if" cond = Expression()
	"then" thenExpr = Expression()
	(
		elseExpr = ElseIfExpression()
	|
		"else" elseExpr = Expression()
	)
	("end" | "endif")
	{
		return new ExprIf(cond, thenExpr, elseExpr);
	}
}

ExprIf ElseIfExpression() :
{
	Expression cond;
	Expression thenExpr;
	Expression elseExpr;
}
{
	"elsif"
	cond = Expression()
	"then"
	thenExpr = Expression()
	(
		elseExpr = ElseIfExpression()
	|
		"else"
		elseExpr = Expression()
	)
	{
		return new ExprIf(cond, thenExpr, elseExpr);
	}
}

ExprLet LetExpression() :
{
	ImmutableList<TypeDecl> typeDecls = ImmutableList.empty();
	ImmutableList<LocalVarDecl> varDecls;
	Expression expr;
}
{
	<LET>
	varDecls = BlockVarDecls()
	":"
	expr = Expression()
	("end" | "endlet")
	{ return new ExprLet(typeDecls, varDecls, expr); }
}


ExprLambda LambdaExpression() :
{
	ImmutableList<ParameterVarDecl> valuePars;
	TypeExpr type = null;
	Expression expr;
}
{
	<LAMBDA> "(" valuePars = FormalValuePars() ")"
	("-->" type = Type())?
	(
		{
			ImmutableList<TypeDecl> typeDecls = ImmutableList.empty();
			ImmutableList<LocalVarDecl> varDecls;
		}
		"var" varDecls = BlockVarDecls() ":" expr = Expression()
		{
			expr = new ExprLet(typeDecls, varDecls, expr);
		}
	|
		":" expr = Expression()
	)
	("end" | "endlambda")
	{
		return new ExprLambda(valuePars, expr, type);
	}
}

void FormalParameters(ImmutableList.Builder<ParameterTypeDecl> typeDecls, ImmutableList.Builder<ParameterVarDecl> varDecls) :
{
    ParameterTypeDecl typeDecl;
    ParameterVarDecl varDecl;
}
{
    (
        FormalParameter(typeDecls, varDecls)
        (
            "," FormalParameter(typeDecls, varDecls)
        )*
    )?
}

void FormalParameter(ImmutableList.Builder<ParameterTypeDecl> typeDecls, ImmutableList.Builder<ParameterVarDecl> varDecls) :
{
    ParameterTypeDecl typeDecl;
    ParameterVarDecl varDecl;
}
{
    typeDecl = FormalTypeParameter() { typeDecls.add(typeDecl); }
|
    varDecl = FormalValueParameter() { varDecls.add(varDecl); }
}

ImmutableList<ParameterVarDecl> FormalValuePars() :
{
	ImmutableList.Builder<ParameterVarDecl> builder = ImmutableList.builder();
	ParameterVarDecl decl;
}
{
	(
		decl = FormalValueParameter() { builder.add(decl); }
		( "," decl = FormalValueParameter() { builder.add(decl); } )*
	)?
	{
		return builder.build();
	}
}

ParameterVarDecl FormalValueParameter() :
{
    GenericVarDecl varDecl = new GenericVarDecl();
}
{

    VariableVarDecl(varDecl)
	{
		return VarDecl.parameter(ImmutableList.from(varDecl.annotations), varDecl.type, varDecl.name, varDecl.value);
	}
}

ParameterTypeDecl FormalTypeParameter() :
{
    Token id;
}
{
    "type" id=<ID>
    {
        return setPosition(new ParameterTypeDecl(id.image), id, id);
    }
}


ExprProc ProcExpression() :
{
	ImmutableList<ParameterVarDecl> valuePars;
	ImmutableList<TypeDecl> typeDecls = ImmutableList.empty();
	ImmutableList<LocalVarDecl> varDecls = ImmutableList.empty();
	ImmutableList<Statement> stmts;
}
{
	"proc" "(" valuePars = FormalValuePars() ")"
	( "var" varDecls = BlockVarDecls() )?
	( "do" | "begin" )
	stmts = Statements()
	( "end" | "endproc" )
	{
		StmtBlock block = new StmtBlock(typeDecls, varDecls, stmts);
		return new ExprProc(valuePars, ImmutableList.of(block));
	}
}

Expression MapExpression() :
{
	Token first;
	Token last;
	Expression result;
	ImmutableList<ImmutableEntry<Expression, Expression>> mappings;
}
{
	first = "map"
	"{"
	mappings = Mappings()
	{ result = new ExprMap(mappings); }
	(
		":"
		result = ComprehensionFor(result)
	)?
	last = "}"
	{
		return setPosition(result, first, last);
	}
}

ImmutableList<ImmutableEntry<Expression, Expression>> Mappings() :
{
	ImmutableList.Builder<ImmutableEntry<Expression, Expression>> builder = ImmutableList.builder();
	ImmutableEntry<Expression, Expression> mapping;
	Expression key;
	Expression value;
}
{
	(
		key = Expression() "->" value = Expression() { builder.add(ImmutableEntry.of(key, value)); }
		(
			","
			key = Expression() "->" value = Expression() { builder.add(ImmutableEntry.of(key, value)); }
		)*
	)?
	{ return builder.build(); }
}

Expression SetExpression() :
{
	Token first;
	Token last;
	Expression result;
	ImmutableList<Expression> exprs;
}
{
	first = "{"
	exprs = ExpressionList()
	{ result = new ExprSet(exprs); }
	(
		":"
		result = ComprehensionFor(result)
	)?
	last = "}"
	{
		return setPosition(result, first, last);
	}
}

Expression ListExpression() :
{
	Token first;
	Token last;
    Expression result;
	ImmutableList<Expression> exprs;
}
{
	first = "["
	exprs = ExpressionList()
	{ result = new ExprList(exprs); }
	(
		":"
		result = ComprehensionFor(result)
	)?
	last = "]"
	{
		return setPosition(result, first, last);
	}
}

Expression TupleExpression() :
{
  Token first;
  Token last;
  Expression expr;
  ImmutableList.Builder<Expression> exprs = ImmutableList.builder();
}
{
  first = "("
  expr = Expression() { exprs.add(expr); }
  (
    ","
    expr = Expression() { exprs.add(expr); }
  )+
  last = ")"
  { return setPosition(new ExprTuple(exprs.build()), first, last); }
}

Expression ComprehensionFor(Expression contents) :
{
	TypeExpr type = null;
	Token id;
	ImmutableList.Builder<GeneratorVarDecl> varDecls = ImmutableList.builder();
	Expression collection;
	Expression filter;
	ImmutableList.Builder<Expression> filters = ImmutableList.builder();
}
{
	"for"
	(
		LOOKAHEAD(Type() <ID>)
		type = Type()
	)?
	id = <ID>
	{
		varDecls.add(VarDecl.generator(id.image));
	}
	(
		","
		id = <ID>
		{
			varDecls.add(VarDecl.generator(id.image));
		}
	)*
	"in"
	collection = Expression()
	(
		LOOKAHEAD(2)
		","
		filter = Expression()
		{ filters.add(filter); }
	)*
	(
		","
		contents = ComprehensionFor(contents)
	)?
	{
		return new ExprComprehension(new Generator(type, varDecls.build(), collection), filters.build(), contents);
	}
}


/* Type expressions */
TypeExpr Type() :
{
  TypeExpr type;
  Expression expr = null;
  Token last = null;
  ImmutableList.Builder<TypeExpr> builder = ImmutableList.builder();
}
{
  type = SimpleType() { builder.add(type); }
  (
    "|" type = SimpleType() { builder.add(type); }
  )*
  (
    "["
    expr = Expression()
    last = "]"
  )?
  {
    ImmutableList<TypeExpr> types = builder.build();
    if (types.size() == 1) {
      type = types.get(0);
    } else {
      type = setPosition(new UnionTypeExpr(types), types.get(0), types.get(types.size() - 1));
    }
    if (expr == null) {
      return type;
    } else {
      return setPosition(new NominalTypeExpr("List", ImmutableList.of(setPosition(new TypeParameter("type", type), type, type)), ImmutableList.of(setPosition(new ValueParameter("size", expr), expr, expr))), type, last);
    }
  }
}

TypeExpr SimpleType() :
{
  TypeExpr type;
}
{
  (
    type = NominalType()
  |
    type = TupleType()
  |
    type = LambdaType()
  )
  { return type; }
}

TupleTypeExpr TupleType() :
{
  Token first;
  Token last;
  TypeExpr type;
  ImmutableList.Builder<TypeExpr> types = ImmutableList.builder();
}
{
  first = "("
  type = Type() { types.add(type); }
  (
    "," type = Type() { types.add(type); }
  )+
  last = ")"
  { return setPosition(new TupleTypeExpr(types.build()), first, last); }
}

NominalTypeExpr NominalType() :
{
  Token name;
  ImmutableList.Builder<TypeParameter> types = ImmutableList.builder();
  ImmutableList.Builder<ValueParameter> vals = ImmutableList.builder();
  Token last;
}
{
  name = <ID>
  { last = name; }
  (
    "("
    ParameterAssignments(types, vals)
    last = ")"
  )?
  {
    return setPosition(new NominalTypeExpr(name.image, types.build(), vals.build()), name, last);
  }
}

TypeExpr LambdaType() :
{
  Token first;
  Token last;
  TypeExpr type;
  TypeExpr retType = null;
  ImmutableList.Builder<TypeExpr> types = ImmutableList.builder();
}
{
  first = "["
  (
    type = Type() { types.add(type); }
    (
      "," type = Type() { types.add(type); }
    )*
  )?
  "-->"
  (
    retType = Type()
  )?
  last = "]"
  {
    if (retType == null) {
      return setPosition(new ProcedureTypeExpr(types.build()), first, last);
    } else {
      return setPosition(new FunctionTypeExpr(types.build(), retType), first, last);
    }
  }
}

/* Type definitions */
GlobalTypeDecl GlobalTypeDecl() :
{
  Availability availability = Availability.PUBLIC;
  GlobalTypeDecl declaration;
}
{
  (
    availability = Availability()
  )?
  (
    declaration = AliasType(availability)
  |
    declaration = AlgebraicType(availability)
  )
  { return declaration; }
}

AliasTypeDecl AliasType(Availability availability) :
{
  Token first;
  Token last;
  Token name;
  TypeExpr type;
}
{
  first = "alias"
  name = <ID>
  ":"
  type = Type()
  last = "end"
  { return setPosition(new AliasTypeDecl(name.image, availability, type), first, last); }
}

AlgebraicTypeDecl AlgebraicType(Availability availability) :
{
  Token first;
  Token last;
  Token name;
  AlgebraicTypeDecl declaration;
  ImmutableList.Builder<ParameterTypeDecl> typeDecls = ImmutableList.builder();
  ImmutableList.Builder<ParameterVarDecl> varDecls = ImmutableList.builder();
}
{
  first = "type"
  name = <ID>
  (
    "("
      FormalParameters(typeDecls, varDecls)
    ")"
  )?
  ":"
  (
      declaration = ProductTypeDecl(availability, name, typeDecls.build(), varDecls.build())
  |
      declaration = SumTypeDecl(availability, name, typeDecls.build(), varDecls.build())
  )
  last = "end"
  { return setPosition(declaration, first, last); }
}

ProductTypeDecl ProductTypeDecl(Availability availability, Token name, List<ParameterTypeDecl> typeDecls, List<ParameterVarDecl> varDecls) :
{
    Token first;
    Token last;
    FieldDecl field;
    ImmutableList.Builder<FieldDecl> fields = ImmutableList.builder();
}
{
    first = "("
    (
        field = FieldDecl() { fields.add(field); }
        ( "," field = FieldDecl() { fields.add(field); } )*
    )?
    last = ")"
    { return setPosition(new ProductTypeDecl(name.image, availability, typeDecls, varDecls, fields.build()), first, last); }
}

FieldDecl FieldDecl() :
{
    TypeExpr type;
	Token name;
}
{
    type = Type()
    name = <ID>
    { return setPosition(new FieldDecl(type, name.image), type, name); }
}

SumTypeDecl SumTypeDecl(Availability availability, Token name, List<ParameterTypeDecl> typeDecls, List<ParameterVarDecl> varDecls) :
{
    SumTypeDecl.VariantDecl first;
    SumTypeDecl.VariantDecl last;
    SumTypeDecl.VariantDecl variant;
    ImmutableList.Builder<SumTypeDecl.VariantDecl> variants = ImmutableList.builder();
}
{
    variant = VariantDecl() { variants.add(variant); }
    { last = first = variant; }
    (
        "|"
        variant = VariantDecl() { variants.add(variant); }
        { last = variant; }
    )*
    { return setPosition(new SumTypeDecl(name.image, availability, typeDecls, varDecls, variants.build()), first, last); }
}

SumTypeDecl.VariantDecl VariantDecl() :
{
	Token name;
	Token last;
	FieldDecl field;
	ImmutableList.Builder<FieldDecl> fields = ImmutableList.builder();
}
{
    name = <ID>
    { last = name; }
    (
        "("
        field = FieldDecl() { fields.add(field); }
        ( "," field = FieldDecl() { fields.add(field); } )*
        last = ")"
    )?
    { return setPosition(new SumTypeDecl.VariantDecl(name.image, fields.build()), name, last); }
}

/* Statements */
Statement Statement() :
{
	Statement stmt;
	ImmutableList.Builder<Annotation> annotations = ImmutableList.builder();
	Annotation annotation;
}
{
	( annotation = Annotation() {annotations.add(annotation);} )*
	(
		LOOKAHEAD(LValue() ":=")
		stmt = AssignmentStmt()
	|
		//LOOKAHEAD(IfStmt()) to detect the procedure call "if x then p else q end (y)"
		LOOKAHEAD("if")
		stmt = IfStmt()
	|
		LOOKAHEAD(2, {processDescription})
		stmt = ReadStmt()
	|
		LOOKAHEAD(2, {processDescription})
		stmt = WriteStmt()
	|
		LOOKAHEAD(QID() ";", {processDescription})
		stmt = ActionSelectionStmt()
	|
		stmt = CallStmt()
	|
		stmt = CaseStmt()
	|
		stmt = BlockStmt()
	|
		stmt = WhileStmt()
	|
		stmt = ForeachStmt()
	)
	{
		return (stmt != null) ? stmt.withAnnotations(annotations.build()) : null;
	}
}

ImmutableList<Statement> Statements() :
{
	ImmutableList.Builder<Statement> stmts = ImmutableList.builder();
	Statement stmt;
}
{
	( stmt = Statement() { stmts.add(stmt); } )*
	{ return stmts.build(); }
}

Statement ReadStmt() :
{
	Token port;
	LValue lvalue;
	ImmutableList.Builder<LValue> lvalues = ImmutableList.builder();
	Expression repeatExpr = null;
}
{
	port = <ID>
	"-->"
	lvalue = LValue() { lvalues.add(lvalue); }
	(
		","
		lvalue = LValue() { lvalues.add(lvalue); }
	)*
	(
		"repeat"
		repeatExpr = Expression()
	)?
	";"
	{
		Port p = new Port(port.image);
		p.setPosition(port.beginLine, port.beginColumn, port.endLine, port.endColumn);
		return new StmtRead(p, lvalues.build(), repeatExpr);
	}
}

Statement WriteStmt() :
{
	Token port;
	Expression value;
	ImmutableList.Builder values = ImmutableList.builder();
	Expression repeatExpr = null;
}
{
	port = <ID>
	"<--"
	value = Expression() { values.add(value); }
	(
		","
		value = Expression() { values.add(value); }
	)*
	(
		"repeat"
		repeatExpr = Expression()
	)?
	";"
	{
		Port p = new Port(port.image);
		p.setPosition(port.beginLine, port.beginColumn, port.endLine, port.endColumn);
		return new StmtWrite(p, values.build(), repeatExpr);
	}
}

Statement ActionSelectionStmt() :
{
	QID tag;
}
{
	tag = QID() ";"
	{
		return null;
	}
}


StmtAssignment AssignmentStmt() :
{
	LValue lvalue;
	Expression rvalue;
	Token end;
}
{
	lvalue = LValue()
	":="
	rvalue = Expression()
	end = ";"
	{
		StmtAssignment result = new StmtAssignment(lvalue, rvalue);
		result.setPosition(lvalue.getFromLineNumber(), lvalue.getFromColumnNumber(), end.endLine, end.endColumn);
		return result;
	}
}

LValue LValue() :
{
	Variable var;
	Field field;
	Expression index;
  Nth nth;
	LValue lvalue;
	Token end;
}
{
	var = Variable()
	{
		lvalue = new LValueVariable(var);
		lvalue.setPosition(var, var);
	}
	(
		(
			LOOKAHEAD(<DOT_SHARP>)
			<DOT_SHARP> nth = Nth()
			{
				lvalue = new LValueNth(lvalue, nth);
				lvalue.setPosition(var, nth);
			}
		|
			"." field = Field()
			{
				lvalue = new LValueField(lvalue, field);
				lvalue.setPosition(var, field);
			}
		|
			"["
			index = Expression()
			end = "]"
			{
				lvalue = new LValueIndexer(lvalue, index);
				lvalue.setPosition(var.getFromLineNumber(), var.getFromColumnNumber(), end.endLine, end.endColumn);
			}
		)
	)*
	{
		return lvalue;
	}
}

Field Field() :
{
	Token id;
}
{
	id = <ID>
	{ return setPosition(new Field(id.image), id, id); }
}

Nth Nth() :
{
  Token decimal;
}
{
  decimal = <INTEGER>
  { return setPosition(new Nth(Integer.valueOf(decimal.image)), decimal, decimal); }
}

StmtCall CallStmt() :
{
	Expression proc;
	ImmutableList<Expression> args;
}
{
	proc = VariableExpression() // should be any expression, but is not because of conflict with annotations on statements
	"("
	args = ExpressionList()
	")"
	";"
	{
		return new StmtCall(proc, args);
	}
}

StmtCase CaseStmt() :
{
    Token first;
    Token last;
    Expression scrutinee;
    StmtCase.Alternative alternative;
    ImmutableList.Builder<StmtCase.Alternative> alternatives = ImmutableList.builder();
}
{
    first = "case"
    scrutinee = Expression()
    "of"
    (
        alternative = CaseStmtAlternative() { alternatives.add(alternative); }
        (
            alternative = CaseStmtAlternative() { alternatives.add(alternative); }
        )*
    )?
    last = "end"
    { return setPosition(new StmtCase(scrutinee, alternatives.build()), first, last); }
}

StmtCase.Alternative CaseStmtAlternative() :
{
    Pattern pattern;
    Expression guard;
    ImmutableList.Builder<Expression> guards = ImmutableList.builder();
    ImmutableList<Statement> statements;
    Token last;
}
{
    pattern = Pattern()
    (
        "guard"
        guard = Expression() { guards.add(guard); }
        (
            "," guard = Expression() { guards.add(guard); }
        )*
    )?
    "do"
    statements = Statements()
    last = "end"
    { return setPosition(new StmtCase.Alternative(pattern, guards.build(), statements), pattern, last); }
}

StmtBlock BlockStmt() :
{
	ImmutableList<LocalVarDecl> varDecls = ImmutableList.empty();
	ImmutableList<Statement> stmts;
}
{
	"begin"
	(
		"var"
		varDecls = BlockVarDecls()
		"do"
	)?
	stmts = Statements()
	"end"
	{
		return new StmtBlock(ImmutableList.empty(), varDecls, stmts);
	}
}

StmtIf IfStmt() :
{
	Expression cond;
	ImmutableList<Statement> thenStmts;
	ImmutableList<Statement> elseStmts = null;
}
{
	"if"
	cond = Expression()
	"then"
	thenStmts = Statements()
	(
		elseStmts = ElseIfStmt()
	|
		"else"
		elseStmts = Statements()
	)?
	"end"
	{
		return new StmtIf(cond, thenStmts, elseStmts);
	}
}

ImmutableList<Statement> ElseIfStmt() :
{
	Expression cond;
	Statement thenStmt;
	ImmutableList<Statement> thenStmts;
	Statement elseStmt;
	ImmutableList<Statement> elseStmts = null;
}
{
	"elsif"
	cond = Expression()
	"then"
	thenStmts = Statements()
	(
		elseStmts = ElseIfStmt()
	|
		"else"
		elseStmts = Statements()
	)?
	{
		return ImmutableList.of(new StmtIf(cond, thenStmts, elseStmts));
	}
}

StmtWhile WhileStmt() :
{
	Expression cond;
	ImmutableList<LocalVarDecl> varDecls = ImmutableList.empty();
	ImmutableList<Statement> statements;
}
{
	"while"
	cond = Expression()
	(
		"var"
		varDecls = BlockVarDecls()
	)?
	"do"
	statements = Statements()
	"end"
	{
		if (varDecls.isEmpty()) {
			return new StmtWhile(cond, statements);
		} else {
			return new StmtWhile(cond, ImmutableList.of(new StmtBlock(ImmutableList.empty(), varDecls, statements)));
		}
	}
}

StmtForeach ForeachStmt() :
{
	StmtForeach stmt;
}
{
	stmt = ForeachStmtHeader()
	"end"
	{
		return stmt;
	}
}

StmtForeach ForeachStmtHeader() :
{
	TypeExpr type = null;
	Token id;
	ImmutableList.Builder<GeneratorVarDecl> varDecls = ImmutableList.builder();
	Expression collection;
	Expression filter;
	ImmutableList.Builder<Expression> filters = ImmutableList.builder();
	ImmutableList<Statement> body;
}
{
	"foreach"
	(
		LOOKAHEAD(2)
		type = Type()
	)?
	id = <ID>
	{ varDecls.add(VarDecl.generator(id.image)); }
	(
		","
		id = <ID>
		{ varDecls.add(VarDecl.generator(id.image)); }
	)*
	"in"
	 collection = Expression()
	(
		LOOKAHEAD(2)
		","
		filter = Expression()
		{ filters.add(filter); }
	)*
	body = ForeachStmtBody()
	{
		return new StmtForeach(new Generator(type, varDecls.build(), collection), filters.build(), body);
	}
}

ImmutableList<Statement> ForeachStmtBody() :
{
	Statement result;
	ImmutableList<LocalVarDecl> varDecls = null;
	ImmutableList<Statement> stmts;
}
{
	"," result = ForeachStmtHeader()
	{
		return ImmutableList.of(result);
	}
|
	(
		"var"
		varDecls = BlockVarDecls()
	)?
	"do"
	stmts = Statements()
	{
		if (varDecls == null) {
			return stmts;
		} else {
			return ImmutableList.of(new StmtBlock(ImmutableList.empty(), varDecls, stmts));
		}
	}
}

/* Parameters */

void ParameterAssignments(ImmutableList.Builder<TypeParameter> typeParameters, ImmutableList.Builder<ValueParameter> valueParameters) :
{
}
{
    (
        ParameterAssignment(typeParameters, valueParameters)
        ( "," ParameterAssignment(typeParameters, valueParameters) )*
    )?
}

void ParameterAssignment(ImmutableList.Builder<TypeParameter> types, ImmutableList.Builder<ValueParameter> vals) :
{
	Token name;
	TypeExpr type;
	Expression expr;
}
{
	(
		LOOKAHEAD(2)
		(name = <ID> | name = <TYPE>)
		":" type = Type()
		{ types.add(setPosition(new TypeParameter(name.image, type), name, type)); }
	|
		name = <ID>
		"=" expr = Expression()
		{ vals.add(setPosition(new ValueParameter(name.image, expr), name, expr)); }
	)
}
